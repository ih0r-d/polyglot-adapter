package io.github.ih0rd.codegen;

import io.github.ih0rd.contract.ContractClass;
import io.github.ih0rd.contract.ContractMethod;
import io.github.ih0rd.contract.ContractParam;
import java.nio.charset.StandardCharsets;
import java.security.MessageDigest;
import java.security.NoSuchAlgorithmException;
import java.util.Set;
import java.util.StringJoiner;
import java.util.TreeSet;

/// # JavaInterfaceGenerator
///
/// Generates Java interface source code from a contract model.
///
/// Responsibilities:
/// - Render method signatures
/// - Collect required imports
/// - Produce deterministic, clean output
///
/// Design notes:
/// - Uses {@link JavaTypeRenderer} for type rendering
/// - Automatically injects imports
/// - No framework annotations
/// - No runtime logic
///
public final class JavaInterfaceGenerator {

    private static final String INTERFACE_BODY_TEMPLATE =
            """
                    public interface %s {
                    
                    %s}
                    """;

    private static final String GENERATED_HEADER_TEMPLATE =
            """
            /**
             * This file was generated by polyglot-codegen.
             *
             * SHA-256 checksum: %s
             *
             * Any manual changes will be overwritten.
             */
            """;
    JavaTypeRenderer renderer = new JavaTypeRenderer();

    /// ### generate
    ///
    /// Generates full Java interface source.
    ///
    public String generate(ContractClass contract, String basePackage) {

        renderer.reset();

        StringBuilder methodsBuilder = new StringBuilder();

        // render methods first (so imports get collected)
        for (ContractMethod method : contract.methods()) {
            methodsBuilder.append(renderMethod(method)).append("\n");
        }

        Set<String> imports = new TreeSet<>(renderer.getImports());

        String interfaceBodyContent = String.format(
                INTERFACE_BODY_TEMPLATE,
                contract.name(),
                methodsBuilder
        );

        String checksum = sha256(interfaceBodyContent);

        StringBuilder file = new StringBuilder();

        file.append(String.format(GENERATED_HEADER_TEMPLATE, checksum));

        file.append("package ")
                .append(basePackage)
                .append(";\n\n");

        // imports
        if (!imports.isEmpty()) {
            for (String imp : imports) {
                file.append("import ").append(imp).append(";\n");
            }
            file.append("\n");
        }

        file.append(interfaceBodyContent);

        return file.toString();
    }
    /// ### sha256
    ///
    /// Calculates the SHA-256 hash of the given content.
    ///
    private String sha256(String content) {
        try {
            MessageDigest digest = MessageDigest.getInstance("SHA-256");
            byte[] hash = digest.digest(content.getBytes(StandardCharsets.UTF_8));
            StringBuilder hexString = new StringBuilder();
            for (byte b : hash) {
                String hex = Integer.toHexString(0xff & b);
                if (hex.length() == 1) {
                    hexString.append('0');
                }
                hexString.append(hex);
            }
            return hexString.toString();
        } catch (NoSuchAlgorithmException e) {
            throw new RuntimeException("SHA-256 algorithm not available", e);
        }
    }

    /// ### renderMethod
    ///
    /// Renders a single method signature.
    ///
    private String renderMethod(ContractMethod method) {

        StringBuilder sb = new StringBuilder();

        String returnType = renderer.render(method.returnType());

        sb.append("    ")
                .append(returnType)
                .append(" ")
                .append(method.name())
                .append("(")
                .append(renderParams(method))
                .append(");\n");

        return sb.toString();
    }

    /// ### renderParams
    ///
    /// Renders parameters using renderer.
    ///
    private String renderParams(ContractMethod method) {

        StringJoiner joiner = new StringJoiner(", ");

        for (ContractParam param : method.params()) {
            joiner.add(
                    renderer.render(param.type()) + " " + param.name()
            );
        }

        return joiner.toString();
    }
}